#include "SolGen.h"
#include "FileUtils.h"
#include "version.h"

#include <algorithm>
#include <cstring>
#include <list>
#include <map>
#include <regex>
#include <string>
#include <string_view>
#include <unordered_map>
#include <set>
#include <iomanip>
#include <ctime>
#include <sstream>

namespace solgen {
constexpr auto header = R"(
#ifndef SOLGEN_SOLGEN_H
#define SOLGEN_SOLGEN_H

#include <sol/sol.hpp>

namespace solgen {
template<typename T> void registerLuaUsertype(sol::table &table);
}

#endif // SOLGEN_SOLGEN_H
)";

constexpr auto source = R"(// Auto-generated file
// Do not edit! Your changes will be overwritten!
// Generated by $PNAME v$PVER $DATE
// $URL

$INCLUDES
namespace $NAMESPACE {
template<typename T> void registerLuaUsertype(sol::table &table);
$DECLARATIONS
$IMPL} // $NAMESPACE
)";

constexpr auto usertype = R"(
template<> void registerLuaUsertype<$TYPE>(sol::table &table) {
    if (table["$NAME"].valid())
        return;

    auto ctors = $CTORSOBJ;
    auto usertype = table.new_usertype<$TYPE>(
        "$NAME", $OPERATORS
        sol::meta_function::construct, ctors,
        sol::call_constructor, ctors,
        sol::base_classes, sol::bases<$BASES>());
    $FIELDS $FUNCTIONS $ENUMS $REGDEPS
}
)";

constexpr auto declaration = "template<> void registerLuaUsertype<$TYPE>(sol::table &table);";
constexpr auto constructors = "sol::constructors<$CTORS>()";
constexpr auto factories = "sol::factories($FACTORIES)";
constexpr auto readOnlyField = R"(usertype["$FNAME"] = sol::readonly_property(sol::var($TYPE::$FNAME));)";
constexpr auto field = R"(usertype["$FNAME"] = &$TYPE::$FNAME;)";
constexpr auto function = R"(usertype["$FNAME"] = $FPTR;)";
constexpr auto functionPtr = "&$TYPE::$FNAME";
constexpr auto overload = "sol::overload($OVERLOADS)";
constexpr auto defaultParamsOverload = "[]($TYPE &self$ARGS) { $RETself.$FNAME($ANAMES); }";
constexpr auto defaultParamsStaticOverload = "[]($ARGS) { $RET$TYPE::$FNAME($ANAMES); }";
constexpr auto factoryLambda = "[]($ARGS) { return $FACTORY; }";
constexpr auto funcCast = "static_cast<$RETTYPE ($TYPE::*)($ARGS)$QUALIFIERS>(&$TYPE::$FNAME)";
constexpr auto staticFuncCast = "static_cast<$RETTYPE (*)($ARGS)>(&$TYPE::$FNAME)";
constexpr auto newEnum = R"($TABLE.new_enum("$NAME", $KEYS);)";
constexpr auto property = R"(usertype["$PNAME"] = sol::property($PROP);)";
constexpr auto regType = "registerLuaUsertype<$TYPE>($TABLE);";

constexpr auto usertypeTableName = "usertypeTable";

std::string format(std::string_view str, const std::unordered_map<std::string_view, std::string> &values) {
    std::string result;
    size_t pos = 0;
    size_t startPos = 0;
    char buff[64];
    int size = 0;

    while ((pos = str.find('$', pos)) != std::string::npos) {
        ++pos;

        while (pos < str.size() && str[pos] >= 'A' && str[pos] <= 'Z')
            buff[size++] = str[pos++];

        buff[size] = '\0';

        if (values.find(buff) != values.end()) {
            result += str.substr(startPos, pos - size - 1 - startPos);
            result += values.at(buff);
        }

        startPos = pos;
        size = 0;

        if (startPos == str.size() - 1)
            break;
    }

    if (startPos < str.size())
        result += str.substr(startPos);

    return result;
}

enum class ArgIgnore {
    None, Name, Type
};

template<typename T = Args>
std::string argsToString(const T &args, ArgIgnore ignore = ArgIgnore::Name) {
    if (args.empty())
        return {};

    auto it = args.begin();

    auto typeStr = [&]() -> std::string {
        if (ignore == ArgIgnore::Type) return "";

        if constexpr (std::is_same_v<T, Args>) {
            return it->type.getCanonicalName();
        } else {
            return it->type;
        }
    };

    auto nameStr = [&]() -> std::string {
        if (ignore == ArgIgnore::Name) return "";
        if (ignore == ArgIgnore::Type) return it->name;
        return ' ' + it->name;
    };

    std::string result = typeStr() + nameStr();
    ++it;

    while (it != args.end()) {
        result.insert(0, typeStr() + nameStr() + ", ");
        ++it;
    }

    return result;
}

template<typename T>
inline auto len(const std::forward_list<T> &forwardList) {
    return std::distance(forwardList.begin(), forwardList.end());
}

void readIncludes(const GenOptions &options, std::set<File> &out) {
    if (auto it = options.find(GenOptions::Include); it != options.end()) {
        const auto &includes = std::any_cast<const GenOptions::Include_t&>(it->second);
        out.insert(includes.begin(), includes.end());
    }
}

std::string SolGen::genCtorsCode(Class *cl) const {
    if (cl->isAbstract)
        return "sol::no_constructor";

    std::string ctors;
    std::string factory = cl->options.getFactory();

    for (Class::Constructor &ctor : cl->ctors) {
        if (ctor.access != Access::Public || ctor.options.isIgnore())
            continue;

        if (factory.empty()) { // constructors
            ctors += cl->type.getCanonicalName() + '(' + argsToString(ctor.args) + "), ";
        } else { // factories
            ctors += "\n        " + format(factoryLambda, {
                {"ARGS",    argsToString(ctor.args, ArgIgnore::None)},
                {"FACTORY", format(factory, {
                    {"TYPE",    cl->type.getCanonicalName()},
                    {"ANAMES",  argsToString(ctor.args, ArgIgnore::Type)}
                })}
            }) + ", ";
        }
    }

    if (ctors.empty()) {
        if (len(cl->ctors) == 0) { // no ctors specified - exists default
            if (factory.empty()) { // ctor
                ctors = cl->type.getCanonicalName() + "()";
            } else { // factory
                ctors += format(factoryLambda, {
                    {"ARGS",    ""},
                    {"FACTORY", format(factory, {{"TYPE", cl->type.getCanonicalName()}, {"ANAMES", ""}})}
                });
            }
        }
    } else {
        ctors.erase(ctors.size() - 2, 2);
    }

    return factory.empty() ?
        format(constructors, {{"CTORS", ctors}}) :
        format(factories, {{"FACTORIES", ctors}});
}

std::string SolGen::genOperatorsCode(Class *cl) const {
    std::string ops;
    auto &funs = cl->functions;
    auto typeName = cl->type.getCanonicalName();

    auto addOperator = [&](const std::string &code) {
        if (ops.empty())
            ops += '\n';
        ops += "        " + code + ", ";
    };

    // TODO: check overloads & ignores

    if (auto it = funs.find("operator=="); it != funs.end()) {
        addOperator("sol::meta_function::equal_to, &" + typeName + "::operator==");
    } else if (it = funs.find("operator+"); it != funs.end()) {
        addOperator("sol::meta_function::addition, &" + typeName + "::operator+");
    } else if (it = funs.find("operator-"); it != funs.end()) {
        addOperator("sol::meta_function::subtraction, &" + typeName + "::operator-");
    } else if (it = funs.find("operator*"); it != funs.end()) {
        addOperator("sol::meta_function::multiplication, &" + typeName + "::operator*");
    } else if (it = funs.find("operator/"); it != funs.end()) {
        addOperator("sol::meta_function::division, &" + typeName + "::operator/");
    } else if (it = funs.find("operator<"); it != funs.end()) {
        addOperator("sol::meta_function::less_than, &" + typeName + "::operator<");
    } else if (it = funs.find("operator[]"); it != funs.end()) {
        Function *index {nullptr};
        Function *new_index {nullptr};

        for (auto &fun : it->second) {
            if (fun.options.isIgnore())
                continue;

            if (fun.isConst) {
                index = &fun;
            } else {
                new_index = &fun;
            }
        }

        auto func_cast = [cl](Function *func) {
            std::string qualifiers;

            if (func->isConst) qualifiers += " const";
            if (func->isVolatile) qualifiers += " volatile";

            return format(funcCast, {
                {"RETTYPE", func->type.getResultType().getCanonicalName()},
                {"TYPE", cl->type.getCanonicalName()},
                {"ARGS", argsToString(func->args)},
                {"QUALIFIERS", qualifiers},
                {"FNAME", func->name}
            });
        };

        if (index) {
            addOperator("sol::meta_function::index, " + func_cast(index));
        }

        if (new_index) {
            addOperator("sol::meta_function::new_index, " + func_cast(new_index));
        }
    }

    return ops;
}

std::string SolGen::genBasesCode(const Type &type) {
    std::string bases;

    for (const Type &base : m_completeBases[type])
        bases += base.getCanonicalName() + ", ";

    if (!bases.empty())
        bases.erase(bases.size() - 2, 2);

    return bases;
}

std::string SolGen::genFieldsCode(Class *cl) const {
    std::string fields;

    for (Field &fld : cl->fields) {
        if (fld.options.isIgnore())
            continue;

        std::unordered_map<std::string_view, std::string> values = {
            {"FNAME", fld.name},
            {"TYPE", cl->type.getCanonicalName()}
        };

        if (fld.isConst) {
            fields += "\n    " + format(readOnlyField, values);
        } else {
            fields += "\n    " + format(field, values);
        }
    }

    return fields;
}

// single function can produce multiple bindings:
// for example if it has default arguments
struct FunVariations {
    Function *fun;
    std::forward_list<std::string> variations; // code
};

struct Property {
    std::string getterCode; // Type getXXX() const;
    std::string setterCode; // void setXXX(Type t);
    Function *getter {nullptr};
    Function *setter {nullptr};
};

using Overloads = std::forward_list<FunVariations>;

FunVariations genFunVariationsSource(Class *cl, Function &fun, long functionsCount) {
    // if function has default arguments, we should create bindings
    // for each variation, e.g:
    //  void foo(int a = 0, float b = 1, double c = 2)
    // generates to:
    //  static_cast<rettype (T::*)(int, float, double)>(&T::foo),
    //  [](T &self) { self.foo(); }
    //  [](T &self, int a) { self.foo(a); }
    //  [](T &self, int a, float b) { self.foo(a, b); }

    // if function has arguments of type
    //  std::vector<T>& / const std::vector<T>&
    //  std::map<T>& / const std::map<T>&
    //  std::unordered_map<T>& / const std::unordered_map<T>&
    // they should be replaced with
    //  std::vector<T> / std::map<T> / std::unordered_map<T>
    // e.g:
    //  void foo(const std::vector<int> &v)
    // becomes:
    //  [](T &self, std::vector<int> v) { self.foo(v); }

    // if function is 'clean' - just bind it

    FunVariations funVariations;
    funVariations.fun = &fun;

    // if there exists custom implementation - use it and
    // skip code generation
    if (auto impl = fun.options.getImpl(); !impl.empty()) {
        funVariations.variations.emplace_front(impl);
        return funVariations;
    }

    // returns empty string if good, otherwise returns good type
    auto isBad = [](const std::string &name) -> std::string { // TODO: maybe somehow remove reference using libclang?
        for (std::string type : {"vector", "map", "unordered_map"}) {
            // (?:const)? *(?:std::)?vector<(.+)> *&
            std::regex rx("(?:const)? *(?:std::)?" + type + "<(.+)> *&");

            for (auto it = std::sregex_iterator(name.begin(), name.end(), rx); it != std::sregex_iterator(); ++it) {
                return "std::" + type + '<' + (*it)[1].str() + '>';
            }
        }

        return {};
    }; // isBad

    struct GoodArg {
        Name name;
        std::string type;
        bool hasDefault;
    };

    std::list<GoodArg> newArgs;
    std::string argsStr;
    std::string argsNames;
    bool badArgs = false;

    for (Arg &arg : fun.args) { // backwards
        if (std::string good = isBad(arg.type.getCanonicalName()); good.empty()) {
            GoodArg argGood;
            argGood.name = arg.name;
            argGood.type = arg.type.getCanonicalName();
            argGood.hasDefault = arg.hasDefault;
            newArgs.insert(newArgs.begin(), argGood);
        } else {
            GoodArg argGood;
            argGood.name = arg.name;
            argGood.type = good;
            argGood.hasDefault = arg.hasDefault;
            newArgs.insert(newArgs.begin(), argGood);
            badArgs = true;
        }
    }

    // just adds overload to funVariations
    auto addOverload = [&](const std::string &overload) {
        funVariations.variations.emplace_front(overload);
    };

    auto addLambdaOverload = [&]() {
        addOverload(format(defaultParamsOverload, {
            {"TYPE",    cl->type.getCanonicalName()},
            {"ARGS",    argsStr.empty() ? "" : ", " + argsStr},
            {"FNAME",   fun.name},
            {"ANAMES",  argsNames.substr(0, argsNames.size() - 2)},
            {"RET",     fun.type.getResultType().getName() == "void" ? "" : "return "}
        }));
    };

    auto addLambdaStaticOverload = [&]() {
        addOverload(format(defaultParamsStaticOverload, {
            {"TYPE",    cl->type.getCanonicalName()},
            {"ARGS",    argsStr},
            {"FNAME",   fun.name},
            {"ANAMES",  argsNames.substr(0, argsNames.size() - 2)},
            {"RET",     fun.type.getResultType().getName() == "void" ? "" : "return "}
        }));
    };

    // add overloading if function has default arguments
    for (GoodArg &arg : newArgs) {
        if (arg.hasDefault) {
            if (!fun.isStatic) {
                addLambdaOverload();
            } else {
                addLambdaStaticOverload();
            }
        }

        argsStr += (argsStr.empty() ? "" : ", ") + arg.type + ' ' + arg.name;
        argsNames += arg.name + ", ";
    }

    if (functionsCount == 1 && !cl->options.isExplicitCast() && !fun.options.isExplicitCast()) {
        if (!badArgs) { // pointer to function without casting
            addOverload(format(functionPtr, {{"TYPE", cl->type.getCanonicalName()}, {"FNAME", fun.name}}));
        } else { // lambda
            addLambdaOverload();
        }
    } else {
        if (!badArgs) { // pointer to function with casting
            std::string qualifiers;

            if (fun.isConst) qualifiers += " const";
            if (fun.isVolatile) qualifiers += " volatile";

            std::unordered_map<std::string_view, std::string> values = {
                {"RETTYPE",     fun.type.getResultType().getCanonicalName()},
                {"TYPE",        cl->type.getCanonicalName()},
                {"ARGS",        argsToString(fun.args)},
                {"FNAME",       fun.name},
                {"QUALIFIERS",  qualifiers}
            };

            if (!fun.isStatic) {
                addOverload(format(funcCast, values));
            } else {
                addOverload(format(staticFuncCast, values));
            }
        } else { // lambda
            if (!fun.isStatic) {
                addLambdaOverload();
            } else {
                addLambdaStaticOverload();
            }
        }
    }

    return funVariations;
} // genFunVariationsSource

std::string SolGen::genFunctionsCode(Class *cl) const {
    std::string functionsCode;
    std::unordered_map<Name, Property> properties;
    std::unordered_map<Name, Overloads> overloads;

    auto &funs = cl->functions;

    auto isOperator = [](const std::string &name) {
        for (auto op : {"operator=", "operator==", "operator!=",
                        "operator<", "operator<=", "operator>", "operator>=",
                        "operator+", "operator-", "operator/", "operator*",
                        "operator[]"})
        {
            if (name == op) {
                return true;
            }
        }

        return false;
    };

    for (auto &funNameData : funs) {
        const std::string &name = funNameData.first;
        std::forward_list<Function> &functions = funNameData.second;

        if (isOperator(name))
            continue;

        long functionsCount = len(functions);

        overloads[name] = Overloads {};

        for (Function &fun : functions) {
            // Note: if the Function has override attrib, we can skip code generation for
            // this function, in case if overriden function in base class is public too;
            // in theory it can reduce lua usertype table size
            if (!fun.options.isIgnore()) {
                overloads[name].emplace_front(genFunVariationsSource(cl, fun, functionsCount));
            }
        }

        std::forward_list<std::string> overloadsList;

        for (FunVariations &funVariations : overloads[name]) {
            for (std::string &ovCode : funVariations.variations) {
                overloadsList.emplace_front(ovCode);
            }
        }

        auto overloadsToString = [&]() -> std::string {
            if (len(overloadsList) == 1)
                return *overloadsList.begin();

            std::string result;

            for (auto &o : overloadsList)
                result += "\n        " + o + ',';

            return result.erase(result.size() - 1);
        };

        if (len(overloadsList) > 1) {
            functionsCode += "\n    " + format(function, {
                {"FNAME", name},
                {"FPTR", format(overload, {{"OVERLOADS", overloadsToString()}})}
            });
        } else if (len(overloadsList) == 1) {
            functionsCode += "\n    " + format(function, {
                {"FNAME", name},
                {"FPTR", overloadsToString()}
            });
        }
    }

    // properties: phase 1: getters
    for (auto & [name, funOverloadsList] : overloads) {
        if (name.size() > 3 && std::string_view(name.c_str(), 3) == "get") {
            // now, find non-void function with 0 arguments
            for (FunVariations &funVariations : funOverloadsList) {
                Function *fun = funVariations.fun;
                auto retTypeName = fun->type.getResultType().getName();

                if (!fun->options.isIgnore() && len(fun->args) == 0 && retTypeName != "void") {
                    std::string propName = name.substr(3);
                    propName[0] = std::tolower(propName[0]);

                    Property prop;
                    prop.getterCode = *funVariations.variations.begin();
                    prop.getter = fun;

                    properties[propName] = prop;
                }
            }
        }
    }

    // phase 2: find setters
    for (auto & [name, funOverloadsList] : overloads) {
        if (name.size() > 3 && std::string_view(name.c_str(), 3) == "set") {
            // now, find void function with 1 argument of type properties[name].type
            for (FunVariations &funVariations : funOverloadsList) {
                Function *fun = funVariations.fun;
                auto retTypeName = fun->type.getResultType().getName();

                if (!fun->options.isIgnore() && len(fun->args) == 1 && retTypeName == "void" &&
                    len(funVariations.variations) == 1)
                {
                    std::string propName = name.substr(3);
                    propName[0] = static_cast<char>(std::tolower(propName[0]));

                    if (auto it = properties.find(propName); it != properties.end()) {
                        Property &prop = it->second;

                        Type &setterType = (*fun->args.begin()).type;
                        Type getterType = prop.getter->type.getResultType();

                        Name setterPropName = fun->options.getPropName();
                        Name getterPropName = prop.getter->options.getPropName();

                        if (setterType == getterType ||
                            (setterPropName == getterPropName && !setterPropName.empty()))
                        {
                            prop.setterCode = *funVariations.variations.begin();
                            prop.setter = fun;
                        }
                    }
                }
            }
        }
    }

    // phase 3: find out prop name & gen code
    for (auto &p : properties) {
        Property &prop = p.second;

        Name getterPropName = prop.getter->options.getPropName();
        Name setterPropName = prop.setter ? prop.setter->options.getPropName() : "";
        Name propName;

        if (!getterPropName.empty() && !setterPropName.empty()) {
            if (getterPropName == setterPropName) {
                propName = getterPropName;
            } else {
                fprintf(stderr, "Warning: property names on setterCode and getterCode are not the same:\n");
                fprintf(stderr, "\t%s: %s\n", prop.getterCode.c_str(), getterPropName.c_str());
                fprintf(stderr, "\t%s: %s\n", prop.setterCode.c_str(), setterPropName.c_str());
            }
        } else if (!getterPropName.empty() && setterPropName.empty()) {
            propName = getterPropName;
        } else if (getterPropName.empty() && !setterPropName.empty()) {
            propName = setterPropName;
        }

        if (propName.empty())
            propName = p.first;

        functionsCode += "\n    " + format(property, {
            {"PNAME", propName},
            {"PROP", prop.getterCode + (prop.setterCode.empty() ? "" : ", " + prop.setterCode)}
        });
    }

    return functionsCode;
}

bool matches(const std::regex &filter, const Type &type) {
    std::string typeName = type.getName();
    return std::sregex_iterator(typeName.begin(), typeName.end(), filter) != std::sregex_iterator();
}

std::string SolGen::genDependenciesReg(Class *cl) const {
    std::string dependencies;

    auto genCode = [&](const std::string &typeName, const std::string &table) {
        dependencies += "\n    " + format(regType, {
            {"TYPE",    typeName},
            {"TABLE",   table}
        });
    };

    auto gen = [&](Class &dep, const std::string &table) {
        if (dep.options.isIgnore() || !matches(filter, dep.type))
            return;
        genCode(dep.type.getCanonicalName(), table);
    };

    for (Class &child : cl->classes)
        gen(child, usertypeTableName);

    for (auto [base, access] : cl->bases) {
        if (access == Access::Public) {
            gen(*base, "table");
        }
    }

    if (auto it = cl->options.find(GenOptions::Dep); it != cl->options.end()) {
        for (const auto &dep : std::any_cast<GenOptions::Dep_t&>(it->second)) {
            genCode(dep, "table");
        }
    }

    return dependencies.empty() ? "" : '\n' + dependencies;
}

void collectPublicBases(const Type &type, const std::unordered_map<Type, Class*> &classes,
                  std::unordered_map<Type, std::set<Type>> &bases)
{
    if (bases.find(type) != bases.end())
        return; // already found

    for (auto [base, access] : classes.at(type)->bases) {
        if (access != Access::Public)
            continue;

        collectPublicBases(base->type, classes, bases);
        bases[type].insert(base->type);

        auto &baseBases = bases[base->type];
        bases[type].insert(baseBases.begin(), baseBases.end());
    }
}

void buildRegenerationMap(const Class &cl, std::unordered_map<File, bool> &regenerationMap, const CmdOptions &options) {
    // one file can contain several classes, so we can return only in case
    // if the file already needs to be regenerated
    if (auto it = regenerationMap.find(cl.absFile); it != regenerationMap.end() && it->second)
        return;

    bool &regenerate = regenerationMap[cl.absFile] = shouldBeRegenerated(cl.absFile, options);

    for (auto [base, access]: cl.bases) {
        // we don't care about non-public base classes
        // since they do not affect the generated code
        if (access != Access::Public)
            continue;

        if (regenerate)
            return;

        buildRegenerationMap(*base, regenerationMap, options);
        regenerate = regenerate || regenerationMap[base->absFile];
    }
}

SolGen::SolGen(const CmdOptions &options): options(options) {}

void SolGen::generate(const PTBuilder &builder) {
    // build regeneration map
    std::unordered_map<File, bool> regenerationMap;

    auto isRegenerate = [&regenerationMap](const File &file, const CmdOptions &options) {
        if (auto it = regenerationMap.find(file); it != regenerationMap.end())
            return it->second;
        return shouldBeRegenerated(file, options);
    };

    if (options.regenerateDerived) {
        for (auto && [type, cl] : builder.allClasses) {
            if (matches(filter, type)) {
                buildRegenerationMap(*cl, regenerationMap, options);
            }
        }
    }

    // iterate over all classes
    for (auto &p : builder.allClasses) {
        const Type &type = p.first;
        Class *cl = p.second;

        // filter
        if (cl->options.isIgnore() || !matches(filter, type))
            continue;

        if (!isRegenerate(cl->absFile, options))
            continue; // no need to generate code for this class - its file unchanged

        if (auto it = m_sources.find(cl->absFile); it == m_sources.end())
            m_sources[cl->absFile] = Sources {};

        Sources &src = m_sources[cl->absFile];

        readIncludes(cl->options, src.sourceIncludes);

        src.sourceIncludes.insert(cl->absFile);

        std::unordered_map<std::string_view, std::string> values;
        values["NAME"] = cl->name;
        values["TYPE"] = cl->type.getCanonicalName();
        values["CTORSOBJ"] = genCtorsCode(cl); // constructors
        values["OPERATORS"] = genOperatorsCode(cl); // operators

        // bases (only public, because we should bind to lua only visible functions)
        collectPublicBases(type, builder.allClasses, m_completeBases);
        values["BASES"] = genBasesCode(type);

        // fields
        values["FIELDS"] = genFieldsCode(cl);

        // functions
        values["FUNCTIONS"] = genFunctionsCode(cl);

        // enums
        bool usertypeTableAdded = false;

        auto addUsertypeTable = [&](std::string &block) {
            if (!usertypeTableAdded) {
                usertypeTableAdded = true;
                block += "\n\n    auto usertypeTable = table[\"" + cl->name + "\"].get<sol::table>();\n";
            }
        };

        std::string enums;

        if (std::distance(cl->enums.begin(), cl->enums.end()) > 0)
            addUsertypeTable(enums);

        for (auto &e : cl->enums) {
            if (e.options.isIgnore())
                continue;

            std::string keys;
            std::string enumType = e.type.getName();

            for (auto &key : e.keys) {
                keys += "\n        \"" + key + "\", "; // key, type::key
                keys += enumType + "::";
                keys += key + ",";
            }

            keys.erase(keys.size() - 1); // erase comma

            enums += "\n    " + format(newEnum, {
                {"TABLE",   usertypeTableName},
                {"NAME",    enumType.substr(enumType.find_last_of(':') + 1)},
                {"KEYS",    keys}
            });
        }

        values["ENUMS"] = enums;

        // reg children & first-level bases
        std::string dependencies;
        auto depCode = genDependenciesReg(cl);

        if (!depCode.empty() && len(cl->classes) > 0)
            addUsertypeTable(dependencies); // add only in case if children exist

        dependencies += depCode;

        values["REGDEPS"] = dependencies;

        src.sourceDecl += "\n" + format(declaration, {{"TYPE", cl->type.getCanonicalName()}});
        src.source += format(usertype, values);
    }

    // gen header & save
    for (auto & [file, src] : m_sources) {
        auto dateStr = []() {
            auto t = std::time(nullptr);
            auto tm = *std::localtime(&t);

            std::ostringstream oss;
            oss << std::put_time(&tm, "%H:%M:%S %d.%m.%Y");

            return oss.str();
        };

        std::string date = dateStr();
        std::string sourceFile = getOutputPath(options.outputDir, file, "cpp");

        // printf("%s\n%s\n%s\n", headerFile.c_str(), sourceFile.c_str(), file.c_str());
        // exit(-1);

        std::string sourceIncludes;

        sourceIncludes += "#include <sol/sol.hpp>\n";

        for (const File &include : src.sourceIncludes)
            sourceIncludes += "#include \"" + include + "\"\n";

        src.source = format(source, {
            {"PNAME",           version::name},
            {"PVER",            version::version},
            {"URL",             version::url},
            {"DATE",            date},
            {"INCLUDES",        sourceIncludes},
            {"DECLARATIONS",    src.sourceDecl},
            {"NAMESPACE",       outNamespace},
            {"IMPL",            src.source}
        });

        mkdirs(getParentDir(sourceFile));
        writeStr(sourceFile, src.source);

        time_t origModTime = getModificationTime(file);
        setModificationTime(sourceFile, origModTime);
    }
}
}
