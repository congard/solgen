#include "Generator.h"
#include "../utils/FileUtils.h"
#include "../version.h"
#include "../utils/format.h"
#include "../utils/matches.h"

#include <iomanip>
#include <ctime>
#include <sstream>
#include <iostream>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

namespace solgen {
constexpr auto header = R"(
#ifndef SOLGEN_SOLGEN_H
#define SOLGEN_SOLGEN_H

#include <sol/sol.hpp>

namespace solgen {
template<typename T> void registerLuaUsertype(sol::table &table, void *userdata = nullptr);
}

#endif // SOLGEN_SOLGEN_H
)";

constexpr auto source = R"(// Auto-generated file
// Do not edit! Your changes will be overwritten!
// Generated by $PNAME v$PVER $DATE
// $URL

$INCLUDES
namespace $NAMESPACE {
template<typename T> void registerLuaUsertype(sol::table &table, void *userdata);
$DECLARATIONS
$IMPL} // $NAMESPACE
)";

void Generator::buildRegenerationMap(const Class &clazz) {
    auto &classAbsPath = clazz.getAbsFile();

    // one file can contain several classes, so we can return only in case
    // if the file already needs to be regenerated
    if (auto it = m_regenerationMap.find(classAbsPath); it != m_regenerationMap.end() && it->second)
        return;

    bool &regenerate = m_regenerationMap[classAbsPath] = FileUtils::shouldBeRegenerated(classAbsPath, getCmdOptions());

    for (auto [base, access] : clazz.getBases()) {
        // we don't care about non-public base classes
        // since they do not affect the generated code
        if (access != Access::Public)
            continue;

        if (regenerate)
            return;

        buildRegenerationMap(*base);

        regenerate = regenerate || m_regenerationMap[base->getAbsFile()];
    }
}

bool Generator::isRegenerate(const File &file) {
    if (auto it = m_regenerationMap.find(file); it != m_regenerationMap.end())
        return it->second;
    return FileUtils::shouldBeRegenerated(file, getCmdOptions());
}

Generator::Generator(const Parser &parser)
    : m_builder(parser) {}

void Generator::generate() {
    auto &options = getCmdOptions();

    if (options.regenerateDerived) {
        for (auto && [type, cl] : m_builder.getAllClasses()) {
            if (matches(m_filter, type)) {
                buildRegenerationMap(*cl);
            }
        }
    }

    auto printOutputFile = [&options](const File &file) {
        if (options.printPaths) {
            std::string sourceFile = FileUtils::getOutputPath(options.outputDir, file);
            std::cout << sourceFile << "\n";
        }
    };

    auto appendGenerated = [this](const File &absPath, const Generated &generated) {
        if (auto it = m_sources.find(absPath); it == m_sources.end())
            m_sources[absPath] = Sources {};

        auto &includes = generated.sourceIncludes;

        Sources &src = m_sources[absPath];
        src.source += generated.source;
        src.sourceDecl += generated.sourceDeclarations;
        src.sourceIncludes.insert(includes.begin(), includes.end());
    };

    // iterate over all classes
    for (auto &p : m_builder.getAllClasses())
        p.second->setGenerator(this);

    for (auto &p : m_builder.getAllClasses()) {
        Class *clazz = p.second;

        // filter
        if (clazz->isIgnore())
            continue;

        auto &classAbsPath = clazz->getAbsFile();
        printOutputFile(classAbsPath);

        if (!isRegenerate(classAbsPath))
            continue; // no need to generate code for this class - its file unchanged

        appendGenerated(classAbsPath, clazz->generate());
    }

    // gen code for enums
    for (auto &p : m_builder.getEnums()) {
        const Enum &e = p.second;
        const File &file = e.getAbsFile();

        // filter
        if (e.getOptions().isIgnore() || !matches(m_filter, e.getType()))
            continue;

        printOutputFile(file);

        if (!isRegenerate(file))
            continue; // no need to generate code for this enum - its file unchanged

        appendGenerated(file, e.generate());
    }
    
    // gen & save
    for (auto & [file, src] : m_sources) {
        auto dateStr = []() {
            auto t = std::time(nullptr);
            auto tm = *std::localtime(&t);

            std::ostringstream oss;
            oss << std::put_time(&tm, "%H:%M:%S %d.%m.%Y");

            return oss.str();
        };

        std::string date = dateStr();
        fs::path sourceFile = FileUtils::getOutputPath(getCmdOptions().outputDir, file);

        std::string sourceIncludes;
        sourceIncludes += "#include <sol/sol.hpp>\n";

        for (const File &include : src.sourceIncludes)
            sourceIncludes += "#include \"" + include + "\"\n";

        src.source = format(source, {
            {"PNAME",        version::name},
            {"PVER",         version::version},
            {"URL",          version::url},
            {"DATE",         date},
            {"INCLUDES",     sourceIncludes},
            {"DECLARATIONS", src.sourceDecl},
            {"NAMESPACE",    m_outNamespace},
            {"IMPL",         src.source}
        });

        if (auto parentPath = sourceFile.parent_path(); !parentPath.empty())
            fs::create_directories(parentPath);

        std::ofstream ofs(sourceFile);
        ofs << src.source;
        ofs.flush();
        ofs.close();

        auto origModTime = std::filesystem::last_write_time(file);
        std::filesystem::last_write_time(sourceFile, origModTime);
    }
}

void Generator::setFilter(const std::regex &filter) {
    m_filter = filter;
}

void Generator::setOutputNamespace(const std::string &name) {
    m_outNamespace = name;
}

const std::regex& Generator::getFilter() const {
    return m_filter;
}

const CmdOptions& Generator::getCmdOptions() const {
    return m_builder.getCmdOptions();
}

const Parser& Generator::getParser() const {
    return m_builder;
}
}
